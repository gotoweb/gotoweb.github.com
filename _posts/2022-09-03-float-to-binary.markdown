---
layout: post
title:  "부동 소수점은 어떻게 바이너리로 표현될까?"
date:   2022-09-03 01:21:00 +0900
categories: 시스템 프로그래밍
---

## 갑자기 시스템 프로그래밍?

인프라를 배우는데, 시스템 프로그래밍을 알면 도움이 되는 부분이 정말 많더라. 물론 수평 확장으로 대다수의 트래픽 문제를 해결하는 시대이기는 하나, 규모의 확장에 따른 애플리케이션 에러는 시스템 영역에 보다 더 깊게 다가가는 경우도 종종 있다. 고급 프로그래머라면 시스템 엔지니어링은 결국 가야하는 길이 아닐까.

부끄러운 이야기지만 그동안 다음에 대해서 정확히 답할 수 없었다.

- float과 double의 차이
- 부동 소수점과 고정 소수점의 차이
- `0.1 + 0.2 === 0.3`이 왜 `false` 인지

## 소수점을 바이너리로 표현하는 방법: 부동 소수점

> 소수점을 바이너리로 표현하는 방법은 부동 소수점 외에 고정 소수점이 있다.
> 이 문서에서는 부동 소수점만 이야기할것이다.

부동 소수점에 대한 이론이나 정의를 먼저 읽으면, 확 와닿지가 않으므로 반대로 왜 부동소수점 방식이 필요한지를 설명하는 편이 이해가 쉽다.

부동 소수점은 **컴퓨터의 모든 구성은 0과 1, 즉 바이너리로 표현할 수 있는데, 어떻게 소수점을 바이너리로 표현하는 것이 효과적인가** 대한 문제이다.


예를 들어, `42.42`라는 숫자를 바이너리로 표현해보자. 이에 대한 결과는  `01000010001010011010111000010100`이다. 최상위 비트 0을 포함하여 32자리를 사용하므로 이건 32비트 표현 방식이다. 즉 float이다. (참고로, double은 64비트로 표현하는 방법이다. 당연히 정밀도가 더 높다.)

진짜인지 확인하기 위해 [IEEE-754 부동 소수점 변환기](https://www.h-schmidt.net/FloatConverter/IEEE754.html)를 사용해보자. 짐작하다시피 IEEE-754는 부동 소수점을 표현하는 방식을 설명한 표준이다.

![](/assets/images/2022-09-03-converter-1.png)

You entered에 `42.42`를 입력하면, 앞서 말한 바이너리 표현이 출력된다.

보통 8비트로 나누면 뭔가 각각의 의미가 있지 않을까 생각할지 모르겠지만, 이 표준을 만들던 시절은 무려 1985년으로 1비트 1비트가 소중하던 시절이다. 따라서 다음의 규칙에 따라 비트를 쪼개고 절약한다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Float_point_example_frac.svg/1200px-Float_point_example_frac.svg.png)

_source: wikipedia_

- 상위 1비트는 음수/양수를 표현한다 0이 양수, 1이 음수이다.
- 다음 8비트는 지수 부분이다.
- 다음 23비트는 가수 부분이다.

지수는 exponential, 즉 얼마나 제곱하느냐를 말하는 것이다. 그럼 몇의 제곱일까? 당연히 바이너리 세계이므로 2의 제곱을 말하는것이다.

수학을 진지하게 다룬적이 없다면 가수라는 말은 좀 어렵다. 그냥 유효숫자라고 표현하겠다. 예를 들어 목성의 질량은 1.898 ✕ 10<sup>27</sup>kg 로 표현한다. 여기서 `1.898`이 가수, 즉 유효숫자이다.

부동 소수점은 앞서 목성의 질량을 표현하듯 과학적 표기법을 따라 표현하는 방식과 매우 흡사한데, 앞서 예제로 든 `42.42`는 다음과 같이 표현할 수 있다.

(-1)<sup>0</sup> ✕ 1.325625 ✕ 2<sup>5</sup> = 42.42

- `0`은 음수/양수를 표현하는 부호다. -1의 1제곱은 -1이므로 음수, 0제곱은 1이므로 양수이다.
- `5`는 지수 부분이며,
- `1.325625`는 유효숫자(가수) 부분이다.

놀랍게도 이 5와 1.325625가 `01000010001010011010111000010100` 안에 인코딩되어 있다.

## 적당히 설명하는 원리

앞서 `42.42`를 바이너리로 표현한 `0_10000100_01010011010111000010100` 는 다음과 같이 구분되어 있다고 했다. (편의상 보기 좋게 *underbar*를 사용했다)

- 상위 1비트 `0`, 즉 양수
- `5`는 8비트 `10000100`
- `1.325625`는 `01010011010111000010100`

`5`나 `1.325625`는 디코딩된 값으로, 사실 아무런 힌트없이 바이너리로부터 해당 값을 알아내기는 어렵다. 규칙이 있다. 실제로 이 규칙을 구현하여 앞서 보았던 변환기를 만드려면 비트 연산이 필수적이다.

이진수 `10000100`에서 십진수 `5`를 얻어내려면, 십진수 `127`을 빼면 된다.

```js
// JavaScript 코드
console.log(0b10000100 - 127)
```

왜 127이냐면, 그냥 그게 규칙이다. 이유야 있겠지만 인코딩은 인코더를 만드는 사람 마음이다. 127은 편차(mantissa/fraction)라고 부른다. 자세한 설명은 위 변환기 사이트에 나와있다.

앞서 비트연산이 필수적이라고 했는데, `01000010001010011010111000010100`에서 `10000100` 이렇게 만드는 것만해도 비트 연산자에 대한 이해가 필수적이다. 유효숫자 범위인 하위 23비트는 날려도 좋기 때문에, 이럴때는 비트 시프트 연산자(`>>`, `<<`)를 써주자.

```js
(0b01000010001010011010111000010100 >> 23).toString(2) // '10000100'
```

이렇게 하면, 비트를 쪼개는 것이 가능하다. 마찬가지로 `01010011010111000010100`를 얻어내려면 비트마스킹, 즉 상위 9비트를 가려주는 작업을 해야 한다. 이 때는 bit AND(`&`) 연산자를 써주자.

```js
(0b01000010001010011010111000010100 &
 0b00000000011111111111111111111111).toString(2) // '1010011010111000010100'
```

`01010011010111000010100`에서 `1.325625`를 얻어내는 것은 작업은 사실 매우 귀찮은 작업이긴 하다. 비트를 하나씩 옮기고 가중치를 계산해서 더하는 작업이 필요하다. (사실 지금 알아둬도 나중에 까먹을 것 같다) 이 과정은 [적절한 링크](http://teaching.idallen.com/cst8281/10w/notes/090_floating_point.html)로 대신한다.

## 중요한 것은...

무한한 소숫점을 유한한 31비트 내에 표현한다는 것은 당연히 **오차가 발생**한다는 의미이기도 하다. 따라서 부동 소수점은 오차가 있는 근사값인 경우가 많다. 이는 특히 계산에 있어서 오류 발생을 유발하는데, 우리에게 익숙한 10진수의 계산값은 실제로 2진수의 계산 결과가 다시 10진수로 변환된 결과이기 때문이다.

자릿수가 짧은 0.1과 같은 단순한 소수 조차도, 2진수로 표현할 때는 정확하게 표현되지 않는다. 다시 앞서 변환기로 가서 Binary Representation에 `00111101110011001100110011001101` 을 입력해보라. 2진수의 표현이 `0.10000000149`으로 표시될 것이다. 반대로 Decimal representation에 `0.1`을 입력하면, 2진수 표현이 아까와 똑같이 나온다. (물론 error due도 있다)

![](/assets/images/2022-09-03-converter-3.png)

_0.1은 00111101110011001100110011001101로 표현된다._

![](/assets/images/2022-09-03-converter-2.png)

_00111101110011001100110011001101의 오차없는 변환은 0.10000000149이다._

이러한 원리를 이해하면, '부동 소수점의 연산에 대해 기댓값과 동등한지를 비교하는 일은 피하는 것이 좋다'는 결론에 다다른다. 대신 적당한 오차 범위에 있는지만 검사하도록 하자. 또한, 엄밀한 과학적인 계산이 필요하다면 double(64비트)을 사용해보자.

이 글은 많은 부분 [Rust in Action](https://www.manning.com/books/rust-in-action) 서적의 도움을 받았다. 시스템 프로그래밍을 배우기에 정말 훌륭한 책이다. 여기까지 간단한 부동소수점 정리를 마친다.